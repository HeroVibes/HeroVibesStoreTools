<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Blurry Wallpaper Generator</title>
    <style>
        :root {
            --bg: #191919;
            --card-bg: #1F1F1F;
            --hover: #323232;
            --outline: #323232;
            --accent: #87A9FF;
            --text-primary: #D4D4D4;
            --text-secondary: #8C8C8C;
            --radius: 8px;
            --blur-strength: 120px;
            --vignette-opacity: 0;
            --grain-opacity: 0.1;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: sans-serif;
            background: var(--bg);
            color: var(--text-primary);
            padding: 24px 16px;
        }

        #app-container {
            max-width: 1200px;
            margin: 0 auto;
            display: flex;
            gap: 24px;
            flex-wrap: wrap;
        }

        #preview-section {
            flex: 1;
            min-width: 300px;
            background: var(--card-bg);
            border: 1px solid var(--outline);
            border-radius: var(--radius);
            padding: 16px;
        }

        #wallpaper-preview {
            width: 100%;
            aspect-ratio: 16 / 9;
            position: relative;
            overflow: hidden;
            background: #000;
            border-radius: var(--radius);
        }

        #texture-overlay, #vignette-overlay, #grain-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 2;
        }

        #vignette-overlay {
            background: radial-gradient(circle, transparent 30%, rgba(0,0,0,0.8) 100%);
            opacity: var(--vignette-opacity);
        }

        #grain-overlay {
            background-image: 
                repeating-linear-gradient(
                    0deg,
                    transparent,
                    transparent 1px,
                    rgba(0,0,0,var(--grain-opacity)) 1px,
                    rgba(0,0,0,var(--grain-opacity)) 2px
                );
        }

        .color-blob {
            position: absolute;
            border-radius: 50%;
            filter: blur(var(--blur-strength));
            transition: all 0.3s ease;
            z-index: 1;
            cursor: move;
        }

        #controls {
            flex: 1;
            min-width: 300px;
            max-width: 450px;
            background: var(--card-bg);
            border: 1px solid var(--outline);
            border-radius: var(--radius);
            padding: 24px 16px;
            display: flex;
            flex-direction: column;
            gap: 24px;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .control-label {
            font-size: 14px;
            font-weight: 600;
            color: var(--text-primary);
        }

        .control-sublabel {
            font-size: 12px;
            color: var(--text-secondary);
            margin-top: -8px;
        }

        #color-grid {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 12px;
        }

        .color-picker-wrapper {
            position: relative;
            width: 100%;
            aspect-ratio: 1;
        }

        .color-picker {
            width: 100%;
            height: 100%;
            border: 2px solid var(--outline);
            border-radius: var(--radius);
            cursor: pointer;
            transition: all 0.2s ease;
            background: transparent;
        }

        .color-picker:hover {
            border-color: var(--accent);
            transform: scale(1.05);
        }

        .color-picker::-webkit-color-swatch-wrapper {
            padding: 0;
        }

        .color-picker::-webkit-color-swatch {
            border: none;
            border-radius: 6px;
        }

        .color-picker::-moz-color-swatch {
            border: none;
            border-radius: 6px;
        }

        .slider-wrapper {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .slider-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .slider-value {
            font-size: 12px;
            color: var(--accent);
            font-weight: 600;
        }

        input[type="range"] {
            width: 100%;
            height: 6px;
            background: var(--outline);
            border-radius: 3px;
            outline: none;
            -webkit-appearance: none;
            appearance: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            background: var(--accent);
            cursor: pointer;
            border-radius: 50%;
            transition: all 0.2s ease;
        }

        input[type="range"]::-webkit-slider-thumb:hover {
            transform: scale(1.2);
        }

        input[type="range"]::-moz-range-thumb {
            width: 16px;
            height: 16px;
            background: var(--accent);
            cursor: pointer;
            border-radius: 50%;
            border: none;
            transition: all 0.2s ease;
        }

        input[type="range"]::-moz-range-thumb:hover {
            transform: scale(1.2);
        }

        .texture-grid, .theme-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
        }

        .texture-option, .theme-option {
            padding: 8px 12px;
            background: var(--bg);
            border: 1px solid var(--outline);
            border-radius: var(--radius);
            cursor: pointer;
            font-size: 12px;
            text-align: center;
            transition: all 0.2s ease;
        }

        .texture-option:hover, .theme-option:hover {
            background: var(--hover);
        }

        .texture-option.active, .theme-option.active {
            background: var(--accent);
            color: #000;
            border-color: var(--accent);
        }

        .button-group {
            display: flex;
            gap: 12px;
            margin-top: 8px;
        }

        .btn {
            position: relative;
            flex: 1;
            padding: 12px 16px;
            border-radius: var(--radius);
            background: var(--card-bg);
            color: var(--text-primary);
            border: 1px solid rgba(255,255,255,0.06);
            cursor: pointer;
            overflow: hidden;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.2s ease;
        }

        .btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 75%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.15), transparent);
            transform: skewX(-25deg);
            transition: left 0.7s ease-in-out;
        }

        .btn:hover::before {
            left: 125%;
        }

        .btn:hover {
            background: var(--hover);
        }

        .btn-primary {
            background: var(--accent);
            color: #000;
            border-color: var(--accent);
        }

        .btn-primary:hover {
            background: #9BB8FF;
        }

        .btn:focus-visible {
            outline: none;
            box-shadow: 0 0 0 3px rgba(135,169,255,0.12);
        }

        #resolution-select {
            padding: 12px;
            background: var(--bg);
            border: 1px solid var(--outline);
            border-radius: var(--radius);
            color: var(--text-primary);
            font-size: 14px;
        }

        @media (max-width: 768px) {
            #app-container {
                gap: 16px;
            }

            #controls {
                max-width: 100%;
            }

            #color-grid {
                grid-template-columns: repeat(auto-fill, minmax(40px, 1fr));
            }

            .texture-grid, .theme-grid {
                grid-template-columns: repeat(2, 1fr);
            }
        }
    </style>
</head>
<body>
    <div id="app-container">
        <div id="preview-section">
            <div id="wallpaper-preview">
                <div id="grain-overlay"></div>
                <div id="texture-overlay"></div>
                <div id="vignette-overlay"></div>
            </div>
        </div>

        <div id="controls">
            <div class="control-group">
                <div class="control-label">Themes</div>
                <div class="theme-grid">
                    <div class="theme-option" data-theme="random">Random</div>
                    <div class="theme-option" data-theme="neon">Neon</div>
                    <div class="theme-option" data-theme="pastel">Pastel</div>
                    <div class="theme-option" data-theme="earth">Earth</div>
                    <div class="theme-option" data-theme="fire">Fire</div>
                    <div class="theme-option" data-theme="ocean">Ocean</div>
                </div>
            </div>

            <div class="control-group">
                <div class="control-label">Colors</div>
                <div class="control-sublabel">Click to change, drag in preview to position</div>
                <div id="color-grid"></div>
                <div class="button-group">
                    <button class="btn" id="add-blob-btn">Add Blob</button>
                    <button class="btn" id="remove-blob-btn">Remove Blob</button>
                </div>
            </div>

            <div class="control-group">
                <div class="control-label">Background Color</div>
                <div class="color-picker-wrapper" style="width: 60px;">
                    <input type="color" class="color-picker" id="bg-color-picker">
                </div>
            </div>

            <div class="control-group">
                <div class="slider-wrapper">
                    <div class="slider-header">
                        <div class="control-label">Blur Strength</div>
                        <div class="slider-value" id="blur-value">120px</div>
                    </div>
                    <input type="range" id="blur-slider" min="30" max="300" value="120">
                </div>
            </div>

            <div class="control-group">
                <div class="slider-wrapper">
                    <div class="slider-header">
                        <div class="control-label">Blob Size</div>
                        <div class="slider-value" id="size-value">100%</div>
                    </div>
                    <input type="range" id="size-slider" min="50" max="200" value="100">
                </div>
            </div>

            <div class="control-group">
                <div class="slider-wrapper">
                    <div class="slider-header">
                        <div class="control-label">Brightness</div>
                        <div class="slider-value" id="brightness-value">100%</div>
                    </div>
                    <input type="range" id="brightness-slider" min="50" max="150" value="100">
                </div>
            </div>

            <div class="control-group">
                <div class="slider-wrapper">
                    <div class="slider-header">
                        <div class="control-label">Saturation</div>
                        <div class="slider-value" id="saturation-value">100%</div>
                    </div>
                    <input type="range" id="saturation-slider" min="0" max="200" value="100">
                </div>
            </div>

            <div class="control-group">
                <div class="slider-wrapper">
                    <div class="slider-header">
                        <div class="control-label">Vignette</div>
                        <div class="slider-value" id="vignette-value">0%</div>
                    </div>
                    <input type="range" id="vignette-slider" min="0" max="100" value="0">
                </div>
            </div>

            <div class="control-group">
                <div class="slider-wrapper">
                    <div class="slider-header">
                        <div class="control-label">Grain</div>
                        <div class="slider-value" id="grain-value">10%</div>
                    </div>
                    <input type="range" id="grain-slider" min="0" max="50" value="10">
                </div>
            </div>

            <div class="control-group">
                <div class="control-label">Texture Overlay</div>
                <div class="texture-grid">
                    <div class="texture-option active" data-texture="none">None</div>
                    <div class="texture-option" data-texture="noise">Noise</div>
                    <div class="texture-option" data-texture="glass">Glass</div>
                    <div class="texture-option" data-texture="paper">Paper</div>
                </div>
            </div>

            <div class="control-group">
                <div class="control-label">Resolution</div>
                <select id="resolution-select">
                    <option value="3840x2160">4K Landscape (3840x2160)</option>
                    <option value="2160x3840">4K Portrait (2160x3840)</option>
                    <option value="1920x1080">Full HD (1920x1080)</option>
                    <option value="1080x1920">Mobile (1080x1920)</option>
                </select>
            </div>

            <div class="button-group">
                <button class="btn" id="random-btn">Randomize</button>
                <button class="btn btn-primary" id="download-btn">Download</button>
            </div>

        </div>
    </div>

    <canvas id="render-canvas" style="display: none;"></canvas>
    <canvas id="temp-canvas" style="display: none;"></canvas>

    <script>
        const preview = document.getElementById('wallpaper-preview');
        const textureOverlay = document.getElementById('texture-overlay');
        const vignetteOverlay = document.getElementById('vignette-overlay');
        const grainOverlay = document.getElementById('grain-overlay');
        const colorGrid = document.getElementById('color-grid');
        const bgColorPicker = document.getElementById('bg-color-picker');
        const blurSlider = document.getElementById('blur-slider');
        const sizeSlider = document.getElementById('size-slider');
        const brightnessSlider = document.getElementById('brightness-slider');
        const saturationSlider = document.getElementById('saturation-slider');
        const vignetteSlider = document.getElementById('vignette-slider');
        const grainSlider = document.getElementById('grain-slider');
        const blurValue = document.getElementById('blur-value');
        const sizeValue = document.getElementById('size-value');
        const brightnessValue = document.getElementById('brightness-value');
        const saturationValue = document.getElementById('saturation-value');
        const vignetteValue = document.getElementById('vignette-value');
        const grainValue = document.getElementById('grain-value');
        const textureOptions = document.querySelectorAll('.texture-option');
        const themeOptions = document.querySelectorAll('.theme-option');
        const addBlobBtn = document.getElementById('add-blob-btn');
        const removeBlobBtn = document.getElementById('remove-blob-btn');
        const randomBtn = document.getElementById('random-btn');
        const downloadBtn = document.getElementById('download-btn');
        const resolutionSelect = document.getElementById('resolution-select');
        const canvas = document.getElementById('render-canvas');
        const ctx = canvas.getContext('2d');
        const tempCanvas = document.getElementById('temp-canvas');
        const tempCtx = tempCanvas.getContext('2d');

        const state = {
            blobs: [],
            sizeMultiplier: 1,
            brightness: 100,
            saturation: 100,
            vignette: 0,
            grain: 0.1,
            texture: 'none',
            backgroundColor: '#000000',
            textureParams: {
                noise: { opacity: 0.1 },
                glass: { blur: 2, noise: 0.02 },
                paper: { opacity: 0.05 }
            },
            maxBlobs: 10,
            minBlobs: 1
        };

        const generateRandomColor = () => {
            const hue = Math.floor(Math.random() * 360);
            const saturation = Math.floor(Math.random() * 30) + 60;
            const lightness = Math.floor(Math.random() * 30) + 40;
            return hslToHex(hue, saturation, lightness);
        };

        const hslToHex = (h, s, l) => {
            l /= 100;
            const a = s * Math.min(l, 1 - l) / 100;
            const f = n => {
                const k = (n + h / 30) % 12;
                const color = l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);
                return Math.round(255 * color).toString(16).padStart(2, '0');
            };
            return `#${f(0)}${f(8)}${f(4)}`;
        };

        const randomInt = (min, max) => Math.floor(Math.random() * (max - min + 1)) + min;

        function randomizeTextureParams() {
            state.textureParams.noise.opacity = randomInt(8, 20) / 100;
            state.textureParams.glass.blur = randomInt(1, 4);
            state.textureParams.glass.noise = randomInt(1, 4) / 100;
            state.textureParams.paper.opacity = randomInt(3, 8) / 100;
        }

        function createBlob(id) {
            const blobElement = document.createElement('div');
            blobElement.classList.add('color-blob');
            blobElement.id = id;
            preview.appendChild(blobElement);

            const pickerWrapper = document.createElement('div');
            pickerWrapper.classList.add('color-picker-wrapper');
            const colorPicker = document.createElement('input');
            colorPicker.type = 'color';
            colorPicker.classList.add('color-picker');
            colorPicker.id = `${id}-color`;
            pickerWrapper.appendChild(colorPicker);
            colorGrid.appendChild(pickerWrapper);

            makeDraggable(blobElement);

            return { element: blobElement, picker: colorPicker };
        }

        function addBlob() {
            if (state.blobs.length >= state.maxBlobs) return;
            const id = `blob${state.blobs.length + 1}`;
            const { element, picker } = createBlob(id);
            const blobState = {
                id,
                color: generateRandomColor(),
                x: randomInt(-20, 80),
                y: randomInt(-20, 80),
                baseSize: randomInt(200, 500)
            };
            state.blobs.push(blobState);
            picker.value = blobState.color;
            picker.addEventListener('input', (e) => {
                blobState.color = e.target.value;
                updatePreview();
            });
            updatePreview();
            scheduleHeightCheck();
        }

        function removeBlob() {
            if (state.blobs.length <= state.minBlobs) return;
            const removed = state.blobs.pop();
            const blobElement = document.getElementById(removed.id);
            blobElement.remove();
            colorGrid.lastChild.remove();
            updatePreview();
            scheduleHeightCheck();
        }

        function makeDraggable(element) {
            let isDragging = false;
            let startX, startY, initialLeft, initialTop;

            const onDown = (e) => {
                isDragging = true;
                startX = e.clientX || e.touches[0].clientX;
                startY = e.clientY || e.touches[0].clientY;
                initialLeft = parseFloat(element.style.left) || 0;
                initialTop = parseFloat(element.style.top) || 0;
                element.style.transition = 'none';
            };

            const onMove = (e) => {
                if (!isDragging) return;
                const clientX = e.clientX || e.touches[0].clientX;
                const clientY = e.clientY || e.touches[0].clientY;
                const dx = (clientX - startX) / preview.clientWidth * 100;
                const dy = (clientY - startY) / preview.clientHeight * 100;
                const newX = initialLeft + dx;
                const newY = initialTop + dy;
                element.style.left = `${newX}%`;
                element.style.top = `${newY}%`;
                const blobState = state.blobs.find(b => b.id === element.id);
                if (blobState) {
                    blobState.x = newX;
                    blobState.y = newY;
                }
            };

            const onUp = () => {
                isDragging = false;
                element.style.transition = 'all 0.3s ease';
                updatePreview();
            };

            element.addEventListener('pointerdown', onDown);
            document.addEventListener('pointermove', onMove);
            document.addEventListener('pointerup', onUp);
            element.addEventListener('touchstart', onDown, { passive: false });
            document.addEventListener('touchmove', onMove, { passive: false });
            document.addEventListener('touchend', onUp);
        }

        function updatePreview() {
            document.documentElement.style.setProperty('--blur-strength', `${blurSlider.value}px`);
            blurValue.textContent = `${blurSlider.value}px`;
            sizeValue.textContent = `${sizeSlider.value}%`;
            brightnessValue.textContent = `${brightnessSlider.value}%`;
            saturationValue.textContent = `${saturationSlider.value}%`;
            vignetteValue.textContent = `${vignetteSlider.value}%`;
            grainValue.textContent = `${grainSlider.value}%`;

            state.sizeMultiplier = sizeSlider.value / 100;
            state.brightness = brightnessSlider.value;
            state.saturation = saturationSlider.value;
            state.vignette = vignetteSlider.value / 100;
            state.grain = grainSlider.value / 100;

            document.documentElement.style.setProperty('--vignette-opacity', state.vignette);
            document.documentElement.style.setProperty('--grain-opacity', state.grain);

            preview.style.backgroundColor = state.backgroundColor;
            preview.style.filter = `brightness(${state.brightness}%) saturate(${state.saturation}%)`;

            state.blobs.forEach(blobState => {
                const blobElement = document.getElementById(blobState.id);
                const adjustedSize = blobState.baseSize * state.sizeMultiplier;
                
                blobElement.style.backgroundColor = blobState.color;
                blobElement.style.left = `${blobState.x}%`;
                blobElement.style.top = `${blobState.y}%`;
                blobElement.style.width = `${adjustedSize}px`;
                blobElement.style.height = `${adjustedSize}px`;

                const picker = document.getElementById(`${blobState.id}-color`);
                if (picker) picker.value = blobState.color;
            });
            applyTexture();
        }

        function applyTexture() {
            textureOverlay.style.backgroundImage = 'none';
            textureOverlay.style.backdropFilter = 'none';
            textureOverlay.style.opacity = 1;

            if (state.texture === 'noise') {
                textureOverlay.style.backgroundImage = `
                    repeating-linear-gradient(
                        0deg,
                        transparent,
                        transparent 2px,
                        rgba(0,0,0,${state.textureParams.noise.opacity}) 2px,
                        rgba(0,0,0,${state.textureParams.noise.opacity}) 4px
                    )
                `;
            } else if (state.texture === 'glass') {
                textureOverlay.style.backdropFilter = `blur(${state.textureParams.glass.blur}px)`;
                textureOverlay.style.backgroundImage = `
                    repeating-linear-gradient(
                        0deg,
                        transparent,
                        transparent 2px,
                        rgba(0,0,0,${state.textureParams.glass.noise}) 2px,
                        rgba(0,0,0,${state.textureParams.glass.noise}) 4px
                    )
                `;
            } else if (state.texture === 'paper') {
                textureOverlay.style.backgroundImage = `
                    repeating-linear-gradient(
                        0deg,
                        transparent,
                        transparent 1px,
                        rgba(255,255,255,${state.textureParams.paper.opacity}) 1px,
                        rgba(255,255,255,${state.textureParams.paper.opacity}) 2px
                    ),
                    repeating-linear-gradient(
                        90deg,
                        transparent,
                        transparent 1px,
                        rgba(255,255,255,${state.textureParams.paper.opacity}) 1px,
                        rgba(255,255,255,${state.textureParams.paper.opacity}) 2px
                    )
                `;
                textureOverlay.style.opacity = 0.5;
            }
        }

        function applyTheme(theme) {
            let baseHue = randomInt(0, 360);
            let colors = [];
            switch (theme) {
                case 'neon':
                    colors = ['#FF00FF', '#00FFFF', '#FFFF00', '#FF0000', '#00FF00'];
                    state.backgroundColor = '#000000';
                    break;
                case 'pastel':
                    colors = ['#FFD3E0', '#D3FFEB', '#D3E0FF', '#FFEBD3', '#E0D3FF'];
                    state.backgroundColor = '#FFFFFF';
                    break;
                case 'earth':
                    colors = ['#4E7D3E', '#8B4513', '#228B22', '#556B2F', '#A0522D'];
                    state.backgroundColor = '#F5F5DC';
                    break;
                case 'fire':
                    colors = ['#FF4500', '#FF8C00', '#FFD700', '#FF0000', '#FFA500'];
                    state.backgroundColor = '#000000';
                    break;
                case 'ocean':
                    colors = ['#00BFFF', '#20B2AA', '#4682B4', '#5F9EA0', '#87CEEB'];
                    state.backgroundColor = '#FFFFFF';
                    break;
                default: // random
                    for (let i = 0; i < state.blobs.length; i++) {
                        colors.push(generateRandomColor());
                    }
                    state.backgroundColor = generateRandomBackgroundColor();
            }
            state.blobs.forEach((blob, i) => {
                blob.color = colors[i % colors.length];
            });
            bgColorPicker.value = state.backgroundColor;
            updatePreview();
        }

        const generateRandomBackgroundColor = () => {
            const roll = Math.random();
            if (roll < 0.4) return '#000000';
            if (roll < 0.8) return '#FFFFFF';
            const hue = Math.floor(Math.random() * 360);
            const saturation = Math.floor(Math.random() * 20) + 10;
            const lightness = Math.random() > 0.5 ? randomInt(0, 15) : randomInt(85, 100);
            return hslToHex(hue, saturation, lightness);
        };

        function randomizeState(theme = 'random') {
            state.blobs.forEach(blob => {
                blob.x = randomInt(-20, 80);
                blob.y = randomInt(-20, 80);
                blob.baseSize = randomInt(200, 500);
            });
            applyTheme(theme);

            blurSlider.value = randomInt(80, 200);
            sizeSlider.value = randomInt(80, 120);
            brightnessSlider.value = randomInt(90, 110);
            saturationSlider.value = randomInt(80, 120);
            vignetteSlider.value = randomInt(0, 50);
            grainSlider.value = randomInt(0, 20);

            const textureTypes = ['none', 'noise', 'glass', 'paper'];
            state.texture = textureTypes[randomInt(0, textureTypes.length - 1)];
            textureOptions.forEach(o => {
                o.classList.toggle('active', o.dataset.texture === state.texture);
            });
            randomizeTextureParams();

            updatePreview();
            scheduleHeightCheck();
        }

        async function downloadImage() {
            const res = resolutionSelect.value.split('x');
            const DOWNLOAD_WIDTH = parseInt(res[0]);
            const DOWNLOAD_HEIGHT = parseInt(res[1]);

            canvas.width = DOWNLOAD_WIDTH;
            canvas.height = DOWNLOAD_HEIGHT;
            tempCanvas.width = DOWNLOAD_WIDTH;
            tempCanvas.height = DOWNLOAD_HEIGHT;

            ctx.fillStyle = state.backgroundColor;
            ctx.fillRect(0, 0, DOWNLOAD_WIDTH, DOWNLOAD_HEIGHT);

            const previewRect = preview.getBoundingClientRect();
            const scaleX = DOWNLOAD_WIDTH / previewRect.width;
            const scaleY = DOWNLOAD_HEIGHT / previewRect.height;
            const scaleFactor = (scaleX + scaleY) / 2;

            const scaledBlur = parseInt(blurSlider.value, 10) * scaleFactor;
            ctx.filter = `blur(${scaledBlur}px) brightness(${state.brightness}%) saturate(${state.saturation}%)`;

            state.blobs.forEach(blobState => {
                ctx.fillStyle = blobState.color;
                ctx.beginPath();
                
                const adjustedSize = blobState.baseSize * state.sizeMultiplier;
                const canvasX = (blobState.x / 100) * DOWNLOAD_WIDTH - (adjustedSize * scaleFactor / 2);
                const canvasY = (blobState.y / 100) * DOWNLOAD_HEIGHT - (adjustedSize * scaleFactor / 2);
                const canvasWidth = adjustedSize * scaleFactor;
                const canvasHeight = canvasWidth; // circle for now

                ctx.arc(canvasX + canvasWidth / 2, canvasY + canvasHeight / 2, canvasWidth / 2, 0, 2 * Math.PI);
                ctx.fill();
            });

            ctx.filter = 'none';

            // Apply grain
            ctx.fillStyle = `rgba(0, 0, 0, ${state.grain})`;
            for (let i = 0; i < DOWNLOAD_WIDTH * DOWNLOAD_HEIGHT / 100; i++) {
                ctx.fillRect(
                    Math.random() * DOWNLOAD_WIDTH,
                    Math.random() * DOWNLOAD_HEIGHT,
                    1, 1
                );
            }

            // Apply texture
            if (state.texture === 'noise') {
                ctx.fillStyle = `rgba(0, 0, 0, ${state.textureParams.noise.opacity})`;
                for (let i = 0; i < DOWNLOAD_WIDTH * DOWNLOAD_HEIGHT / 25; i++) {
                    ctx.fillRect(
                        Math.random() * DOWNLOAD_WIDTH,
                        Math.random() * DOWNLOAD_HEIGHT,
                        1, 1
                    );
                }
            } else if (state.texture === 'glass') {
                tempCtx.filter = `blur(${state.textureParams.glass.blur * scaleFactor}px)`;
                tempCtx.drawImage(canvas, 0, 0);
                ctx.drawImage(tempCanvas, 0, 0);
                ctx.fillStyle = `rgba(0, 0, 0, ${state.textureParams.glass.noise})`;
                for (let i = 0; i < DOWNLOAD_WIDTH * DOWNLOAD_HEIGHT / 50; i++) {
                    ctx.fillRect(
                        Math.random() * DOWNLOAD_WIDTH,
                        Math.random() * DOWNLOAD_HEIGHT,
                        1, 1
                    );
                }
            } else if (state.texture === 'paper') {
                ctx.fillStyle = `rgba(255, 255, 255, ${state.textureParams.paper.opacity})`;
                for (let x = 0; x < DOWNLOAD_WIDTH; x += 2) {
                    ctx.fillRect(x, 0, 1, DOWNLOAD_HEIGHT);
                }
                for (let y = 0; y < DOWNLOAD_HEIGHT; y += 2) {
                    ctx.fillRect(0, y, DOWNLOAD_WIDTH, 1);
                }
            }

            // Apply vignette
            const gradient = ctx.createRadialGradient(
                DOWNLOAD_WIDTH / 2, DOWNLOAD_HEIGHT / 2, 0,
                DOWNLOAD_WIDTH / 2, DOWNLOAD_HEIGHT / 2, Math.max(DOWNLOAD_WIDTH, DOWNLOAD_HEIGHT) / 2
            );
            gradient.addColorStop(0, 'rgba(0,0,0,0)');
            gradient.addColorStop(1, `rgba(0,0,0,${state.vignette * 0.8})`);
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, DOWNLOAD_WIDTH, DOWNLOAD_HEIGHT);

            const link = document.createElement('a');
            link.download = `blurry-wallpaper-${resolutionSelect.value}.png`;
            link.href = canvas.toDataURL('image/png');
            link.click();
            link.remove();
        }

        // Initialize blobs
        for (let i = 1; i <= 5; i++) {
            addBlob();
        }

        addBlobBtn.addEventListener('click', addBlob);
        removeBlobBtn.addEventListener('click', removeBlob);
        randomBtn.addEventListener('click', () => randomizeState('random'));
        downloadBtn.addEventListener('click', downloadImage);

        blurSlider.addEventListener('input', updatePreview);
        sizeSlider.addEventListener('input', updatePreview);
        brightnessSlider.addEventListener('input', updatePreview);
        saturationSlider.addEventListener('input', updatePreview);
        vignetteSlider.addEventListener('input', updatePreview);
        grainSlider.addEventListener('input', updatePreview);

        bgColorPicker.addEventListener('input', (e) => {
            state.backgroundColor = e.target.value;
            updatePreview();
        });

        textureOptions.forEach(option => {
            option.addEventListener('click', () => {
                textureOptions.forEach(o => o.classList.remove('active'));
                option.classList.add('active');
                state.texture = option.dataset.texture;
                randomizeTextureParams();
                updatePreview();
            });
        });

        themeOptions.forEach(option => {
            option.addEventListener('click', () => {
                const theme = option.dataset.theme;
                if (theme === 'random') {
                    randomizeState();
                } else {
                    randomizeState(theme);
                }
            });
        });

        // Initial setup
        randomizeState();
        bgColorPicker.value = state.backgroundColor;

    // ===== FOURTHWALL SCROLLBAR FIX =====
    let lastHeight = 0;
    let resizeTimer;

    function sendHeight() {
      const height = document.body.scrollHeight;
      
      if (height !== lastHeight) {
        lastHeight = height;
        window.parent.postMessage({ frameHeight: height }, '*');
      }
    }

    function scheduleHeightCheck() {
        clearTimeout(resizeTimer);
        resizeTimer = setTimeout(sendHeight, 150);
    }

    window.addEventListener('load', () => {
        setTimeout(sendHeight, 100);
    });

    window.addEventListener('resize', () => {
        scheduleHeightCheck();
    });
    
    // ===== END OF SCROLLBAR FIX =====
    </script>
</body>
</html>
