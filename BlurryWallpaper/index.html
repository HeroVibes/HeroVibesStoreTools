<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Blurry Wallpaper Generator</title>
    <style>
        :root {
            --bg: #191919;
            --card-bg: #1F1F1F;
            --hover: #323232;
            --outline: #323232;
            --accent: #87A9FF;
            --text-primary: #D4D4D4;
            --text-secondary: #8C8C8C;
            --radius: 8px;
            --blur-strength: 120px;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: sans-serif;
            background: var(--bg);
            color: var(--text-primary);
            padding: 24px 16px;
        }
        
        .hidden {
            display: none !important;
        }

        #app-container {
            max-width: 1200px;
            margin: 0 auto;
            display: flex;
            gap: 24px;
            flex-wrap: wrap;
        }

        #preview-section {
            flex: 1;
            min-width: 300px;
            background: var(--card-bg);
            border: 1px solid var(--outline);
            border-radius: var(--radius);
            padding: 16px;
        }

        #blob-preview-wrapper {
            width: 100%;
            aspect-ratio: 16 / 9;
            position: relative;
            overflow: hidden;
            background: #000;
            border-radius: var(--radius);
        }

        #wavy-preview-canvas {
            width: 100%;
            aspect-ratio: 16 / 9;
            border-radius: var(--radius);
            background: #000;
        }

        #texture-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 2;
        }

        .color-blob {
            position: absolute;
            border-radius: 50%;
            filter: blur(var(--blur-strength));
            transition: all 0.3s ease;
            z-index: 1;
        }

        #controls {
            flex: 1;
            min-width: 300px;
            max-width: 450px;
            background: var(--card-bg);
            border: 1px solid var(--outline);
            border-radius: var(--radius);
            padding: 24px 16px;
            display: flex;
            flex-direction: column;
            gap: 24px;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }
        
        .control-group-divider {
            border: 0;
            height: 1px;
            background: var(--outline);
            margin: 0;
        }

        .control-label {
            font-size: 14px;
            font-weight: 600;
            color: var(--text-primary);
        }

        .control-sublabel {
            font-size: 12px;
            color: var(--text-secondary);
            margin-top: -8px;
        }

        #color-grid, #wavy-color-grid {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 12px;
        }
        
        #wavy-color-grid {
            grid-template-columns: repeat(3, 1fr);
        }

        .color-picker-wrapper {
            position: relative;
            width: 100%;
            aspect-ratio: 1;
        }

        .color-picker {
            width: 100%;
            height: 100%;
            border: 2px solid var(--outline);
            border-radius: var(--radius);
            cursor: pointer;
            transition: all 0.2s ease;
            background: transparent;
        }

        .color-picker:hover {
            border-color: var(--accent);
            transform: scale(1.05);
        }

        .color-picker::-webkit-color-swatch-wrapper {
            padding: 0;
        }

        .color-picker::-webkit-color-swatch {
            border: none;
            border-radius: 6px;
        }

        .color-picker::-moz-color-swatch {
            border: none;
            border-radius: 6px;
        }

        .slider-wrapper {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .slider-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .slider-value {
            font-size: 12px;
            color: var(--accent);
            font-weight: 600;
        }

        input[type="range"] {
            width: 100%;
            height: 6px;
            background: var(--outline);
            border-radius: 3px;
            outline: none;
            -webkit-appearance: none;
            appearance: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            background: var(--accent);
            cursor: pointer;
            border-radius: 50%;
            transition: all 0.2s ease;
        }

        input[type="range"]::-webkit-slider-thumb:hover {
            transform: scale(1.2);
        }

        input[type="range"]::-moz-range-thumb {
            width: 16px;
            height: 16px;
            background: var(--accent);
            cursor: pointer;
            border-radius: 50%;
            border: none;
            transition: all 0.2s ease;
        }

        input[type="range"]::-moz-range-thumb:hover {
            transform: scale(1.2);
        }

        .texture-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
        }

        .texture-option {
            padding: 8px 12px;
            background: var(--bg);
            border: 1px solid var(--outline);
            border-radius: var(--radius);
            cursor: pointer;
            font-size: 12px;
            text-align: center;
            transition: all 0.2s ease;
        }

        .texture-option:hover {
            background: var(--hover);
        }

        .texture-option.active {
            background: var(--accent);
            color: #000;
            border-color: var(--accent);
        }

        .button-group {
            display: flex;
            gap: 12px;
            margin-top: 8px;
        }

        .btn {
            position: relative;
            flex: 1;
            padding: 12px 16px;
            border-radius: var(--radius);
            background: var(--card-bg);
            color: var(--text-primary);
            border: 1px solid rgba(255,255,255,0.06);
            cursor: pointer;
            overflow: hidden;
            font-size: 14px;
            font-weight: 600;
            transition: all 0.2s ease;
        }
        
        .btn:disabled {
            background: var(--outline);
            color: var(--text-secondary);
            cursor: not-allowed;
        }
        
        .btn:disabled::before {
            display: none;
        }

        .btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 75%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.15), transparent);
            transform: skewX(-25deg);
            transition: left 0.7s ease-in-out;
        }

        .btn:hover::before {
            left: 125%;
        }

        .btn:hover:not(:disabled) {
            background: var(--hover);
        }

        .btn-primary:not(:disabled) {
            background: var(--accent);
            color: #000;
            border-color: var(--accent);
        }

        .btn-primary:hover:not(:disabled) {
            background: #9BB8FF;
        }

        .btn:focus-visible {
            outline: none;
            box-shadow: 0 0 0 3px rgba(135,169,255,0.12);
        }

        @media (max-width: 768px) {
            #app-container {
                gap: 16px;
            }

            #controls {
                max-width: 100%;
            }

            .texture-grid {
                grid-template-columns: repeat(3, 1fr);
            }
        }
    </style>
</head>
<body>
    <div id="app-container">
        
        <div id="preview-section">
            <div id="blob-preview-wrapper">
                <div id="texture-overlay"></div>
                <div class="color-blob" id="blob1"></div>
                <div class="color-blob" id="blob2"></div>
                <div class="color-blob" id="blob3"></div>
                <div class="color-blob" id="blob4"></div>
                <div class="color-blob" id="blob5"></div>
            </div>
            <canvas id="wavy-preview-canvas" class="hidden"></canvas>
        </div>

        <div id="controls">

            <div class="control-group">
                <div class="control-label">Generator Style</div>
                <div class="texture-grid" id="style-selector-grid">
                    <div class="texture-option active" data-style="blobs">Blobs</div>
                    <div class="texture-option" data-style="wavy">Wavy</div>
                </div>
            </div>

            <hr class="control-group-divider">

            <div id="blob-controls-wrapper">
                <div class="control-group">
                    <div class="control-label">Colors</div>
                    <div class="control-sublabel">Click to change individual colors</div>
                    <div id="color-grid">
                        <div class="color-picker-wrapper">
                            <input type="color" class="color-picker" id="color1">
                        </div>
                        <div class="color-picker-wrapper">
                            <input type="color" class="color-picker" id="color2">
                        </div>
                        <div class="color-picker-wrapper">
                            <input type="color" class="color-picker" id="color3">
                        </div>
                        <div class="color-picker-wrapper">
                            <input type="color" class="color-picker" id="color4">
                        </div>
                        <div class="color-picker-wrapper">
                            <input type="color" class="color-picker" id="color5">
                        </div>
                    </div>
                </div>

                <div class="control-group">
                    <div class="slider-wrapper">
                        <div class="slider-header">
                            <div class="control-label">Blur Strength</div>
                            <div class="slider-value" id="blur-value">120px</div>
                        </div>
                        <input type="range" id="blur-slider" min="30" max="300" value="120">
                    </div>
                </div>

                <div class="control-group">
                    <div class="slider-wrapper">
                        <div class="slider-header">
                            <div class="control-label">Blob Size</div>
                            <div class="slider-value" id="size-value">100%</div>
                        </div>
                        <input type="range" id="size-slider" min="50" max="200" value="100">
                    </div>
                </div>

                <div class="control-group">
                    <div class="slider-wrapper">
                        <div class="slider-header">
                            <div class="control-label">Brightness</div>
                            <div class="slider-value" id="brightness-value">100%</div>
                        </div>
                        <input type="range" id="brightness-slider" min="50" max="150" value="100">
                    </div>
                </div>

                <div class="control-group">
                    <div class="control-label">Texture Overlay</div>
                    <div class="texture-grid" id="blob-texture-grid">
                        <div class="texture-option active" data-texture="none">None</div>
                        <div class="texture-option" data-texture="noise">Noise</div>
                        <div class="texture-option" data-texture="glass">Glass</div>
                    </div>
                </div>
            </div>
            
            <div id="wavy-controls-wrapper" class="hidden">
                 <div class="control-group">
                    <div class="control-label">Colors</div>
                    <div class="control-sublabel">Select 3 colors for the gradient</div>
                    <div id="wavy-color-grid">
                        <div class="color-picker-wrapper">
                            <input type="color" class="color-picker" id="wavy-color1" value="#FF0000">
                        </div>
                        <div class="color-picker-wrapper">
                            <input type="color" class="color-picker" id="wavy-color2" value="#00FF00">
                        </div>
                        <div class="color-picker-wrapper">
                            <input type="color" class="color-picker" id="wavy-color3" value="#0000FF">
                        </div>
                    </div>
                </div>
                
                <div class="control-group">
                    <div class="slider-wrapper">
                        <div class="slider-header">
                            <div class="control-label">Complexity</div>
                            <div class="slider-value" id="complexity-value">5.0</div>
                        </div>
                        <input type="range" id="complexity-slider" min="1" max="20" value="5" step="0.1">
                    </div>
                </div>
                
                <div class="control-group">
                    <div class="slider-wrapper">
                        <div class="slider-header">
                            <div class="control-label">Speed</div>
                            <div class="slider-value" id="speed-value">0.2</div>
                        </div>
                        <input type="range" id="speed-slider" min="0" max="1" value="0.2" step="0.05">
                    </div>
                </div>
            </div>

            <div class="button-group">
                <button class="btn" id="random-btn">Randomize</button>
                <button class="btn btn-primary" id="download-btn">Download 4K</button>
            </div>

        </div>
    </div>

    <canvas id="render-canvas" style="display: none;"></canvas>
    <canvas id="temp-canvas" style="display: none;"></canvas>

    <script>
        // DOM ELEMENTS (SHARED)
        const randomBtn = document.getElementById('random-btn');
        const downloadBtn = document.getElementById('download-btn');
        const styleSelectors = document.querySelectorAll('#style-selector-grid .texture-option');
        const canvas = document.getElementById('render-canvas');
        const ctx = canvas.getContext('2d');
        const tempCanvas = document.getElementById('temp-canvas');
        const tempCtx = tempCanvas.getContext('2d');

        // DOM ELEMENTS (PREVIEWS)
        const blobPreviewWrapper = document.getElementById('blob-preview-wrapper');
        const wavyPreviewCanvas = document.getElementById('wavy-preview-canvas');
        const wavyPreviewCtx = wavyPreviewCanvas.getContext('2d');

        // DOM ELEMENTS (BLOBS)
        const blobControlsWrapper = document.getElementById('blob-controls-wrapper');
        const preview = document.getElementById('blob-preview-wrapper');
        const textureOverlay = document.getElementById('texture-overlay');
        const blobs = document.querySelectorAll('.color-blob');
        const colorPickers = document.querySelectorAll('#color-grid .color-picker');
        const blurSlider = document.getElementById('blur-slider');
        const sizeSlider = document.getElementById('size-slider');
        const brightnessSlider = document.getElementById('brightness-slider');
        const blurValue = document.getElementById('blur-value');
        const sizeValue = document.getElementById('size-value');
        const brightnessValue = document.getElementById('brightness-value');
        const textureOptions = document.querySelectorAll('#blob-texture-grid .texture-option');
        
        // DOM ELEMENTS (WAVY)
        const wavyControlsWrapper = document.getElementById('wavy-controls-wrapper');
        const wavyColorPickers = document.querySelectorAll('#wavy-color-grid .color-picker');
        const complexitySlider = document.getElementById('complexity-slider');
        const complexityValue = document.getElementById('complexity-value');
        const speedSlider = document.getElementById('speed-slider');
        const speedValue = document.getElementById('speed-value');

        // STATE
        const state = {
            mode: 'blobs', // 'blobs' or 'wavy'
            animationFrameId: null,
            wavyLastTimestamp: 0,
            wavyTime: 0,
            
            blob: {
                blobs: [],
                sizeMultiplier: 1,
                brightness: 100,
                texture: 'none',
                backgroundColor: '#000000',
                textureParams: {
                    noise: { opacity: 0.1 },
                    glass: { blur: 2, noise: 0.02 }
                }
            },
            
            wavy: {
                colors: ['#87A9FF', '#FF87A9', '#A9FF87'],
                complexity: 5,
                speed: 0.2
            }
        };

        // SHARED HELPER FUNCTIONS
        const generateRandomColor = () => {
            const hue = Math.floor(Math.random() * 360);
            const saturation = Math.floor(Math.random() * 30) + 60;
            const lightness = Math.floor(Math.random() * 30) + 40;
            return hslToHex(hue, saturation, lightness);
        };

        const hslToHex = (h, s, l) => {
            l /= 100;
            const a = s * Math.min(l, 1 - l) / 100;
            const f = n => {
                const k = (n + h / 30) % 12;
                const color = l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);
                return Math.round(255 * color).toString(16).padStart(2, '0');
            };
            return `#${f(0)}${f(8)}${f(4)}`;
        };

        const randomInt = (min, max) => Math.floor(Math.random() * (max - min + 1)) + min;
        
        const hexToRgb = (hex) => {
            const r = parseInt(hex.slice(1, 3), 16);
            const g = parseInt(hex.slice(3, 5), 16);
            const b = parseInt(hex.slice(5, 7), 16);
            return [r, g, b];
        };

        const lerp = (a, b, t) => a + (b - a) * t;

        const lerpColor = (color1, color2, t) => {
            const [r1, g1, b1] = color1;
            const [r2, g2, b2] = color2;
            const r = lerp(r1, r2, t);
            const g = lerp(g1, g2, t);
            const b = lerp(b1, b2, t);
            return [r, g, b];
        };

        // PERLIN NOISE IMPLEMENTATION
        // (This is a standard, self-contained 3D Perlin noise implementation)
        const perlin = new (function() {
            this.p = new Uint8Array(512);
            this.perm = new Uint8Array(512);
            this.permMod12 = new Uint8Array(512);
            this.grad3 = [
                [1,1,0], [-1,1,0], [1,-1,0], [-1,-1,0],
                [1,0,1], [-1,0,1], [1,0,-1], [-1,0,-1],
                [0,1,1], [0,-1,1], [0,1,-1], [0,-1,-1]
            ];
            this.init = () => {
                for (let i = 0; i < 256; i++) {
                    this.p[i] = Math.floor(Math.random() * 256);
                }
                for (let i = 0; i < 512; i++) {
                    this.perm[i] = this.p[i & 255];
                    this.permMod12[i] = this.perm[i] % 12;
                }
            };
            this.noise = (x, y, z) => {
                let n0, n1, n2; 
                const F3 = 1.0 / 3.0;
                const s = (x + y + z) * F3;
                const i = Math.floor(x + s);
                const j = Math.floor(y + s);
                const k = Math.floor(z + s);
                const G3 = 1.0 / 6.0;
                const t = (i + j + k) * G3;
                const X0 = i - t;
                const Y0 = j - t;
                const Z0 = k - t;
                const x0 = x - X0;
                const y0 = y - Y0;
                const z0 = z - Z0;
                let i1, j1, k1;
                let i2, j2, k2;
                if (x0 >= y0) {
                    if (y0 >= z0) { i1=1; j1=0; k1=0; i2=1; j2=1; k2=0; }
                    else if (x0 >= z0) { i1=1; j1=0; k1=0; i2=1; j2=0; k2=1; }
                    else { i1=0; j1=0; k1=1; i2=1; j2=0; k2=1; }
                } else {
                    if (y0 < z0) { i1=0; j1=0; k1=1; i2=0; j2=1; k2=1; }
                    else if (x0 < z0) { i1=0; j1=1; k1=0; i2=0; j2=1; k2=1; }
                    else { i1=0; j1=1; k1=0; i2=1; j2=1; k2=0; }
                }
                const x1 = x0 - i1 + G3;
                const y1 = y0 - j1 + G3;
                const z1 = z0 - k1 + G3;
                const x2 = x0 - i2 + 2.0 * G3;
                const y2 = y0 - j2 + 2.0 * G3;
                const z2 = z0 - k2 + 2.0 * G3;
                const x3 = x0 - 1.0 + 3.0 * G3;
                const y3 = y0 - 1.0 + 3.0 * G3;
                const z3 = z0 - 1.0 + 3.0 * G3;
                const ii = i & 255;
                const jj = j & 255;
                const kk = k & 255;
                const gi0 = this.permMod12[ii + this.perm[jj + this.perm[kk]]];
                const gi1 = this.permMod12[ii + i1 + this.perm[jj + j1 + this.perm[kk + k1]]];
                const gi2 = this.permMod12[ii + i2 + this.perm[jj + j2 + this.perm[kk + k2]]];
                const gi3 = this.permMod12[ii + 1 + this.perm[jj + 1 + this.perm[kk + 1]]];
                let t0 = 0.5 - x0 * x0 - y0 * y0 - z0 * z0;
                if (t0 < 0) n0 = 0.0;
                else {
                    t0 *= t0;
                    n0 = t0 * t0 * (this.grad3[gi0][0] * x0 + this.grad3[gi0][1] * y0 + this.grad3[gi0][2] * z0);
                }
                let t1 = 0.5 - x1 * x1 - y1 * y1 - z1 * z1;
                if (t1 < 0) n1 = 0.0;
                else {
                    t1 *= t1;
                    n1 = t1 * t1 * (this.grad3[gi1][0] * x1 + this.grad3[gi1][1] * y1 + this.grad3[gi1][2] * z1);
                }
                let t2 = 0.5 - x2 * x2 - y2 * y2 - z2 * z2;
                if (t2 < 0) n2 = 0.0;
                else {
                    t2 *= t2;
                    n2 = t2 * t2 * (this.grad3[gi2][0] * x2 + this.grad3[gi2][1] * y2 + this.grad3[gi2][2] * z2);
                }
                let t3 = 0.5 - x3 * x3 - y3 * y3 - z3 * z3;
                if (t3 < 0) n3 = 0.0;
                else {
                    t3 *= t3;
                    n3 = t3 * t3 * (this.grad3[gi3][0] * x3 + this.grad3[gi3][1] * y3 + this.grad3[gi3][2] * z3);
                }
                return 32.0 * (n0 + n1 + n2 + n3);
            };
            this.init();
        })();

        // BLOB MODE FUNCTIONS
        function randomizeNoiseParams() {
            state.blob.textureParams.noise.opacity = randomInt(8, 20) / 100;
        }

        function randomizeGlassParams() {
            state.blob.textureParams.glass.blur = randomInt(1, 4);
            state.blob.textureParams.glass.noise = randomInt(1, 4) / 100;
        }

        function randomizeBlobTextureParams() {
            switch (state.blob.texture) {
                case 'noise': randomizeNoiseParams(); break;
                case 'glass': randomizeGlassParams(); break;
            }
        }

        function updateBlobPreview() {
            document.documentElement.style.setProperty('--blur-strength', `${blurSlider.value}px`);
            blurValue.textContent = `${blurSlider.value}px`;
            sizeValue.textContent = `${sizeSlider.value}%`;
            brightnessValue.textContent = `${brightnessSlider.value}%`;
            
            state.blob.sizeMultiplier = sizeSlider.value / 100;
            state.blob.brightness = brightnessSlider.value;

            preview.style.backgroundColor = state.blob.backgroundColor;
            preview.style.filter = `brightness(${state.blob.brightness}%)`;

            state.blob.blobs.forEach((blobState, i) => {
                const blobElement = document.getElementById(blobState.id);
                const adjustedSize = blobState.baseSize * state.blob.sizeMultiplier;
                
                blobElement.style.backgroundColor = blobState.color;
                blobElement.style.left = `${blobState.x}%`;
                blobElement.style.top = `${blobState.y}%`;
                blobElement.style.width = `${adjustedSize}px`;
                blobElement.style.height = `${adjustedSize}px`;

                colorPickers[i].value = blobState.color;
            });
            applyBlobTexture();
        }

        function applyBlobTexture() {
            textureOverlay.style.backgroundImage = 'none';
            textureOverlay.style.backdropFilter = 'none';

            if (state.blob.texture === 'noise') {
                textureOverlay.style.backgroundImage = `
                    repeating-linear-gradient(
                        0deg,
                        transparent,
                        transparent 2px,
                        rgba(0,0,0,${state.blob.textureParams.noise.opacity}) 2px,
                        rgba(0,0,0,${state.blob.textureParams.noise.opacity}) 4px
                    )`;
            } else if (state.blob.texture === 'glass') {
                textureOverlay.style.backdropFilter = `blur(${state.blob.textureParams.glass.blur}px)`;
                textureOverlay.style.backgroundImage = `
                    repeating-linear-gradient(
                        0deg,
                        transparent,
                        transparent 2px,
                        rgba(0,0,0,${state.blob.textureParams.glass.noise}) 2px,
                        rgba(0,0,0,${state.blob.textureParams.glass.noise}) 4px
                    )`;
            }
        }

        function randomizeBlobState() {
            state.blob.blobs = [];
            blobs.forEach((blob, i) => {
                state.blob.blobs.push({
                    id: `blob${i + 1}`,
                    color: generateRandomColor(),
                    x: randomInt(-20, 80),
                    y: randomInt(-20, 80),
                    baseSize: randomInt(200, 500)
                });
            });

            const textureTypes = ['none', 'noise', 'glass'];
            state.blob.texture = textureTypes[randomInt(0, textureTypes.length - 1)];
            textureOptions.forEach(o => {
                o.classList.toggle('active', o.dataset.texture === state.blob.texture);
            });
            randomizeBlobTextureParams();

            const roll = Math.random();
            if (roll < 0.4) state.blob.backgroundColor = '#000000';
            else if (roll < 0.8) state.blob.backgroundColor = '#FFFFFF';
            else {
                const hue = Math.floor(Math.random() * 360);
                const lightness = Math.random() > 0.5 ? randomInt(0, 15) : randomInt(85, 100);
                state.blob.backgroundColor = hslToHex(hue, 15, lightness);
            }

            updateBlobPreview();
        }

        async function downloadBlobImage() {
            const DOWNLOAD_WIDTH = 3840;
            const DOWNLOAD_HEIGHT = 2160;
            
            canvas.width = DOWNLOAD_WIDTH;
            canvas.height = DOWNLOAD_HEIGHT;
            tempCanvas.width = DOWNLOAD_WIDTH;
            tempCanvas.height = DOWNLOAD_HEIGHT;

            ctx.fillStyle = state.blob.backgroundColor;
            ctx.fillRect(0, 0, DOWNLOAD_WIDTH, DOWNLOAD_HEIGHT);

            const previewRect = preview.getBoundingClientRect();
            const scaleX = DOWNLOAD_WIDTH / previewRect.width;
            const scaleY = DOWNLOAD_HEIGHT / previewRect.height;
            const scaleFactor = (scaleX + scaleY) / 2;

            const scaledBlur = parseInt(blurSlider.value, 10) * scaleFactor;
            ctx.filter = `blur(${scaledBlur}px) brightness(${state.blob.brightness}%)`;
            
            state.blob.blobs.forEach(blobState => {
                ctx.fillStyle = blobState.color;
                ctx.beginPath();
                
                const adjustedSize = blobState.baseSize * state.blob.sizeMultiplier;
                const canvasX = (blobState.x / 100) * DOWNLOAD_WIDTH + (adjustedSize * scaleFactor / 2);
                const canvasY = (blobState.y / 100) * DOWNLOAD_HEIGHT + (adjustedSize * scaleFactor / 2);
                const canvasRadius = (adjustedSize / 2) * scaleFactor;
                
                ctx.arc(canvasX, canvasY, canvasRadius, 0, 2 * Math.PI);
                ctx.fill();
            });

            ctx.filter = 'none';

            if (state.blob.texture === 'noise') {
                ctx.fillStyle = `rgba(0, 0, 0, ${state.blob.textureParams.noise.opacity})`;
                for (let i = 0; i < DOWNLOAD_WIDTH * DOWNLOAD_HEIGHT / 25; i++) {
                    ctx.fillRect(Math.random() * DOWNLOAD_WIDTH, Math.random() * DOWNLOAD_HEIGHT, 1, 1);
                }
            } else if (state.blob.texture === 'glass') {
                tempCtx.filter = `blur(${state.blob.textureParams.glass.blur * scaleFactor}px)`;
                tempCtx.drawImage(canvas, 0, 0);
                ctx.drawImage(tempCanvas, 0, 0);

                ctx.fillStyle = `rgba(0, 0, 0, ${state.blob.textureParams.glass.noise})`;
                for (let i = 0; i < DOWNLOAD_WIDTH * DOWNLOAD_HEIGHT / 50; i++) {
                    ctx.fillRect(Math.random() * DOWNLOAD_WIDTH, Math.random() * DOWNLOAD_HEIGHT, 1, 1);
                }
            }
            return canvas.toDataURL('image/png');
        }

        // WAVY MODE FUNCTIONS
        function renderWavyPreview(timestamp) {
            if (state.mode !== 'wavy') return;

            const dt = (timestamp - state.wavyLastTimestamp) / 1000;
            state.wavyLastTimestamp = timestamp;
            if (!isNaN(dt)) {
                state.wavyTime += dt * state.wavy.speed;
            }

            const w = wavyPreviewCanvas.width = 320;
            const h = wavyPreviewCanvas.height = 180;
            wavyPreviewCtx.imageSmoothingEnabled = true;

            const imageData = wavyPreviewCtx.createImageData(w, h);
            const data = imageData.data;
            
            const complexity = state.wavy.complexity / 100;
            const time = state.wavyTime;
            
            const c1 = hexToRgb(state.wavy.colors[0]);
            const c2 = hexToRgb(state.wavy.colors[1]);
            const c3 = hexToRgb(state.wavy.colors[2]);

            for (let y = 0; y < h; y++) {
                for (let x = 0; x < w; x++) {
                    const i = (y * w + x) * 4;
                    
                    const noiseVal = (perlin.noise(x * complexity, y * complexity, time) + 1) / 2; // 0 to 1
                    
                    let color;
                    if (noiseVal < 0.5) {
                        color = lerpColor(c1, c2, noiseVal * 2);
                    } else {
                        color = lerpColor(c2, c3, (noiseVal - 0.5) * 2);
                    }
                    
                    data[i] = color[0];
                    data[i+1] = color[1];
                    data[i+2] = color[2];
                    data[i+3] = 255;
                }
            }
            
            wavyPreviewCtx.putImageData(imageData, 0, 0);
            
            state.animationFrameId = requestAnimationFrame(renderWavyPreview);
        }

        function startWavyAnimation() {
            cancelAnimationFrame(state.animationFrameId);
            state.wavyLastTimestamp = performance.now();
            state.animationFrameId = requestAnimationFrame(renderWavyPreview);
        }

        function stopWavyAnimation() {
            cancelAnimationFrame(state.animationFrameId);
            state.animationFrameId = null;
        }

        function randomizeWavyState() {
            state.wavy.colors = [generateRandomColor(), generateRandomColor(), generateRandomColor()];
            wavyColorPickers[0].value = state.wavy.colors[0];
            wavyColorPickers[1].value = state.wavy.colors[1];
            wavyColorPickers[2].value = state.wavy.colors[2];
            
            state.wavy.complexity = randomInt(20, 100) / 10; // 2.0 to 10.0
            complexitySlider.value = state.wavy.complexity;
            complexityValue.textContent = state.wavy.complexity.toFixed(1);
            
            state.wavy.speed = randomInt(5, 40) / 100; // 0.05 to 0.4
            speedSlider.value = state.wavy.speed;
            speedValue.textContent = state.wavy.speed.toFixed(2);
        }
        
        function updateWavyControls() {
            complexityValue.textContent = parseFloat(complexitySlider.value).toFixed(1);
            state.wavy.complexity = parseFloat(complexitySlider.value);
            
            speedValue.textContent = parseFloat(speedSlider.value).toFixed(2);
            state.wavy.speed = parseFloat(speedSlider.value);
            
            wavyColorPickers.forEach((picker, i) => {
                state.wavy.colors[i] = picker.value;
            });
        }
        
        async function downloadWavyImage() {
            return new Promise((resolve) => {
                const DOWNLOAD_WIDTH = 3840;
                const DOWNLOAD_HEIGHT = 2160;
                
                canvas.width = DOWNLOAD_WIDTH;
                canvas.height = DOWNLOAD_HEIGHT;
                
                const imageData = ctx.createImageData(DOWNLOAD_WIDTH, DOWNLOAD_HEIGHT);
                const data = imageData.data;
            
                const complexity = state.wavy.complexity / 100;
                const time = state.wavyTime;
                
                const c1 = hexToRgb(state.wavy.colors[0]);
                const c2 = hexToRgb(state.wavy.colors[1]);
                const c3 = hexToRgb(state.wavy.colors[2]);
                
                // This is a very heavy loop, so we run it in a timeout
                // to let the "loading" state render first.
                setTimeout(() => {
                    for (let y = 0; y < DOWNLOAD_HEIGHT; y++) {
                        for (let x = 0; x < DOWNLOAD_WIDTH; x++) {
                            const i = (y * DOWNLOAD_WIDTH + x) * 4;
                            const noiseVal = (perlin.noise(x * complexity, y * complexity, time) + 1) / 2;
                            
                            let color;
                            if (noiseVal < 0.5) {
                                color = lerpColor(c1, c2, noiseVal * 2);
                            } else {
                                color = lerpColor(c2, c3, (noiseVal - 0.5) * 2);
                            }
                            
                            data[i] = color[0];
                            data[i+1] = color[1];
                            data[i+2] = color[2];
                            data[i+3] = 255;
                        }
                    }
                    ctx.putImageData(imageData, 0, 0);
                    resolve(canvas.toDataURL('image/png'));
                }, 0);
            });
        }

        // MODE SWITCHING & MAIN INITIALIZATION
        function setStyleMode(mode) {
            state.mode = mode;
            
            const isBlobs = (mode === 'blobs');
            
            // Toggle previews
            blobPreviewWrapper.classList.toggle('hidden', !isBlobs);
            wavyPreviewCanvas.classList.toggle('hidden', isBlobs);
            
            // Toggle controls
            blobControlsWrapper.classList.toggle('hidden', !isBlobs);
            wavyControlsWrapper.classList.toggle('hidden', isBlobs);
            
            // Toggle "active" class on buttons
            styleSelectors.forEach(opt => {
                opt.classList.toggle('active', opt.dataset.style === mode);
            });
            
            // Start/Stop animation
            if (isBlobs) {
                stopWavyAnimation();
                updateBlobPreview(); // Ensure it's up-to-date
            } else {
                startWavyAnimation();
            }
            
            scheduleHeightCheck();
        }

        async function downloadImage() {
            downloadBtn.textContent = 'Rendering 4K...';
            downloadBtn.disabled = true;
            
            let dataUrl;
            if (state.mode === 'blobs') {
                dataUrl = await downloadBlobImage();
            } else {
                dataUrl = await downloadWavyImage();
            }
            
            const link = document.createElement('a');
            link.download = `herovibes-${state.mode}-wallpaper-4k.png`;
            link.href = dataUrl;
            link.click();
            link.remove();
            
            downloadBtn.textContent = 'Download 4K';
            downloadBtn.disabled = false;
        }

        // EVENT LISTENERS (SHARED)
        randomBtn.addEventListener('click', () => {
            if (state.mode === 'blobs') {
                randomizeBlobState();
            } else {
                randomizeWavyState();
            }
        });
        
        downloadBtn.addEventListener('click', downloadImage);
        
        styleSelectors.forEach(option => {
            option.addEventListener('click', () => {
                setStyleMode(option.dataset.style);
            });
        });

        // EVENT LISTENERS (BLOBS)
        blurSlider.addEventListener('input', () => { updateBlobPreview(); scheduleHeightCheck(); });
        sizeSlider.addEventListener('input', () => { updateBlobPreview(); scheduleHeightCheck(); });
        brightnessSlider.addEventListener('input', () => { updateBlobPreview(); scheduleHeightCheck(); });

        colorPickers.forEach((picker, i) => {
            picker.addEventListener('input', (e) => {
                if (state.blob.blobs[i]) {
                    state.blob.blobs[i].color = e.target.value;
                    updateBlobPreview();
                }
            });
        });

        textureOptions.forEach(option => {
            option.addEventListener('click', () => {
                const newTexture = option.dataset.texture;
                if (state.blob.texture === newTexture && newTexture !== 'none') {
                    randomizeBlobTextureParams();
                } else {
                    textureOptions.forEach(o => o.classList.remove('active'));
                    option.classList.add('active');
                    state.blob.texture = newTexture;
                    randomizeBlobTextureParams();
                }
                updateBlobPreview();
                scheduleHeightCheck();
            });
        });
        
        // EVENT LISTENERS (WAVY)
        complexitySlider.addEventListener('input', updateWavyControls);
        speedSlider.addEventListener('input', updateWavyControls);
        wavyColorPickers.forEach(picker => {
            picker.addEventListener('input', updateWavyControls);
        });

        // ===== FOURTHWALL SCROLLBAR FIX =====
        let lastHeight = 0;
        let resizeTimer;

        function sendHeight() {
            const height = document.body.scrollHeight;
            if (height !== lastHeight) {
                lastHeight = height;
                window.parent.postMessage({ frameHeight: height }, '*');
            }
        }

        function scheduleHeightCheck() {
            clearTimeout(resizeTimer);
            resizeTimer = setTimeout(sendHeight, 150);
        }

        window.addEventListener('load', () => {
            randomizeBlobState(); // Init blobs
            randomizeWavyState(); // Init wavy
            setStyleMode('blobs'); // Set default mode
            
            // Set initial wavy values in UI
            wavyColorPickers[0].value = state.wavy.colors[0];
            wavyColorPickers[1].value = state.wavy.colors[1];
            wavyColorPickers[2].value = state.wavy.colors[2];
            complexitySlider.value = state.wavy.complexity;
            speedSlider.value = state.wavy.speed;
            
            // Initial height send
            setTimeout(sendHeight, 100);
        });

        window.addEventListener('resize', () => {
            scheduleHeightCheck();
        });
        // ===== END OF SCROLLBAR FIX =====
    </script>
</body>
</html>
